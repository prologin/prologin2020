// SPDX-License-Identifier: GPL-2.0-or-later
// Copyright (c) 2012-2020 Association Prologin <association@prologin.org>

// This file contains all the API functions for the C language, and all the
// constants, enumerations and structures.
// This file was generated by stechec2-generator. DO NOT EDIT.

#pragma once

#include <stdbool.h>
#include <stdlib.h>

/// Nombre de jardiniers
#define NB_JARDINIERS 2

/// Largeur et hauteur de la grille
#define TAILLE_GRILLE 20

/// Nombre de tours à jouer avant la fin de la partie
#define NB_TOURS 100

/// Durée de vie maximale d'une plante
#define AGE_MAX 10

/// Âge auquel la plante atteint la maturité et peut donc être arrosée
#define AGE_DE_POUSSE 3

/// Portée maximale d'une baffe
#define PORTEE_BAFFE 6

/// Types de ressources existantes
#define NB_TYPES_RESSOURCES 3

/// Apport pour une caractéristique lors de l'arrosage
#define APPORT_CARACTERISTIQUE 10

/// Nombre de points de caractéristiques nécessaires pour pouvoir dépoter une
/// cases plus loins.
#define COUT_PAR_CASE_COLLECTE 15

/// Nombre de points de caractéristiques nécessaires pour pouvoir dépoter une
/// cases plus loins.
#define COUT_PAR_CASE_DEPOTAGE 15

/// Erreurs possibles
typedef enum erreur
{
    OK, ///< L'action s'est effectuée avec succès
    HORS_TOUR, ///< Il est interdit de faire des actions hors de jouer_tour
    HORS_POTAGER, ///< La case désignée n'est pas dans le potager
    CASE_OCCUPEE, ///< Il y a déjà une plante sur la case ciblée
    PAS_DE_PLANTE, ///< Il n'y a pas de plante sur la case ciblée
    MAUVAIS_JARDINIER, ///< La plante n'appartient pas au bon jardinier
    SANS_POT, ///< La plante est déjà dépotée
    DEJA_ARROSEE, ///< La plante a déjà été arrosée
    DEJA_BAFFEE, ///< La plante a déjà baffé ce tour ci
    PAS_ENCORE_ARROSEE, ///< La plante n'as pas encore été arrosée
    PAS_ENCORE_ADULTE, ///< La plante ne peut pas encore être arrosée
    PLANTE_INVALIDE, ///< Les caractéristiques de la plante sont invalides
    TROP_LOIN, ///< La plante n'a pas un assez grand rayon de dépotage
    CARACTERISTIQUE_INVALIDE, ///< Valeur de `Caracteristique` inconnue
    CHIEN_INVALIDE, ///< Valeur de `Chien` inconnue
} erreur;

/// Types d'actions
typedef enum action_type
{
    ACTION_DEPOTER, ///< Action ``depoter``
    ACTION_BAFFER, ///< Action ``baffer``
    ACTION_ARROSER, ///< Action ``arroser``
} action_type;

/// Caractéristiques améliorables d'une plante
typedef enum caracteristique
{
    CARACTERISTIQUE_FORCE, ///< Force
    CARACTERISTIQUE_VIE, ///< Vie 
    CARACTERISTIQUE_ELEGANCE, ///< Élégance
    CARACTERISTIQUE_RAYON_DEPOTAGE, ///< Portée de dépotage
} caracteristique;

/// Types de chien de débug
typedef enum debug_chien
{
    AUCUN_CHIEN, ///< Aucun chien, enlève le chien présent
    CHIEN_BLEU, ///< Chien bleu
    CHIEN_VERT, ///< Chien vert
    CHIEN_ROUGE, ///< Chien rouge
} debug_chien;

struct position;
struct plante;
struct action_hist;

typedef struct action_hist_array
{
    struct action_hist* items;
    size_t length;
} action_hist_array;

typedef struct int_array
{
    int* items;
    size_t length;
} int_array;

typedef struct plante_array
{
    struct plante* items;
    size_t length;
} plante_array;

/// Position dans le jardin, donnée par deux coordonnées.
typedef struct position
{
    int x; ///< Coordonnée : x
    int y; ///< Coordonnée : y
} position;

/// Une plante
typedef struct plante
{
    position pos; ///< Position de la plante
    int jardinier; ///< Jardinier ayant planté la plante
    bool adulte; ///< La plante est adulte
    bool enracinee; ///< La plante a déjà déjà été dépotée
    int vie; ///< Point(s) de vie restant(s) de la plante
    int vie_max; ///< Point(s) de vie maximumde la plante
    int force; ///< Force de la baffe de la plante
    int elegance; ///< Élégance de la plante
    int rayon_deplacement; ///< Distance maximale parcourable par la plante en creusant
    int rayon_collecte; ///< Rayon de collecte des ressources pour la plante
    int_array consommation; ///< Quantité de ressources consommées par la plante
    int age; ///< Âge de la plante
} plante;

/// Représentation d'une action dans l'historique
typedef struct action_hist
{
    action_type atype; ///< Type de l'action
    position position_baffante; ///< Position de la plante baffante (si type d'action ``action_baffer``)
    position position_baffee; ///< Position de la plante baffée (si type d'action ``action_baffer``)
    position position_depart; ///< Position de la plante à déplacer (si type d'action ``action_depoter``)
    position position_arrivee; ///< Position où déplacer la plante (si type d'action ``action_depoter``)
    position position_plante; ///< Position de la plante  (si type d'action ``action_arroser``)
    caracteristique amelioration; ///< Caractéristique à améliorer (si type d'action ``action_arroser``)
} action_hist;

// La plante creuse vers une destination donnée
erreur depoter(position position_depart, position position_arrivee);

// Arrose une plante
erreur arroser(position position_plante, caracteristique amelioration);

// Une plante en gifle une autre
erreur baffer(position position_baffante, position position_baffee);

// Affiche le chien spécifié sur la case indiquée
erreur debug_afficher_chien(position pos, debug_chien chien);

// Renvoie la liste des plantes du jardinier
plante_array plantes_jardinier(int jardinier);

// Renvoie la plante sur la position donnée, s'il n'y en a pas tous les champs
// sont initialisés à -1
plante plante_sur_case(position pos);

// Renvoie la liste des plantes du jardinier qui peuvent être arrosées
plante_array plantes_arrosables(int jardinier);

// Renvoie la liste des plantes du jardinier qui sont adultes
plante_array plantes_adultes(int jardinier);

// Renvoie la liste des plantes du jardinier qui peuvent être dépotées
plante_array plantes_depotables(int jardinier);

// Renvoie les ressources disponibles sur une case donnée
int_array ressources_sur_case(position pos);

// Vérifie si une plante à la position donnée aura suffisamment de ressources
// pour se reproduire. S'il y a déjà une plante à cette position, le calcul
// suposera qu'elle a été remplacée
bool reproduction_possible(position pos, int rayon_collecte, int_array consommation);

// Vérifie si une plante à la position donnée peut se reproduire, retourne faux
// s'il n'y pas de plante à la position donnée
bool plante_reproductible(position pos);

// Caractéristiques d'une plante résultant du croisement de plusieurs parents
// donnés. Les champs sont initialisés à -1 si aucune plante n'est donnée en
// paramètre
plante croisement(plante_array parents);

// Renvoie la liste des actions effectuées par l’adversaire durant son tour,
// dans l'ordre chronologique. Les actions de débug n'apparaissent pas dans
// cette liste.
action_hist_array historique(void);

// Renvoie le score du jardinier ``id_jardinier``. Renvoie -1 si le jardinier
// est invalide.
int score(int id_jardinier);

// Renvoie votre numéro de jardinier.
int moi(void);

// Renvoie le numéro du jardinier adverse.
int adversaire(void);

// Annule la dernière action. Renvoie faux quand il n'y a pas d'action à
// annuler ce tour ci.
bool annuler(void);

// Retourne le numéro du tour actuel.
int tour_actuel(void);

// Affiche le contenu d'une valeur de type erreur
void afficher_erreur(erreur v);

// Affiche le contenu d'une valeur de type action_type
void afficher_action_type(action_type v);

// Affiche le contenu d'une valeur de type caracteristique
void afficher_caracteristique(caracteristique v);

// Affiche le contenu d'une valeur de type debug_chien
void afficher_debug_chien(debug_chien v);

// Affiche le contenu d'une valeur de type position
void afficher_position(position v);

// Affiche le contenu d'une valeur de type plante
void afficher_plante(plante v);

// Affiche le contenu d'une valeur de type action_hist
void afficher_action_hist(action_hist v);
